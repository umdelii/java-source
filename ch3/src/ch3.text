ch3

메소드 
    리턴타입이 존재하는 경우 
        1. 출력문 - 그냥 확인만 할거야~
        2. 변수 - 다음 코드에 쓸거면

컬렉션 프레임워크
    데이터를 담아서 처리하는 방법

Colletions 클래스
    Colletion 프레임워크 에 유용한 메소드 제공
    검색, 정렬 등등

Colletion 인터페이스
    List 인터페이스 (== 배열 개념과 동일함)
        ArrayList, Vector, LinkedList, Stack ...
        순서가 존재

        Stack : 후입선출(LIFO), 입구와 출구가 동일 ex: 접시를 쌓으고 가장 먼저 사용하는건 마지막에 쌓아놨던 접시
            push(넣고), pop(빼고)
            사용 경우 : 수식계산, 수식괄호검사, 응용프로그램에서 undo/redo, 웹브라우저 뒤로/앞으로
        Queue : 선입선출(FIFO), 입구와 출구가 다름, 먼저 들어간 놈이 먼저 나옴
            Queue는 굳이 구현 안함, why? LinkedList로 대체 가능하니까
            사용 경우 : 응용프로그램에서 최근사용문서, 버퍼, 인쇄작업 대기목록 등 
        Deque : 양쪽에서 입구and출구 기능 다 함

        순차적으로 추가/삭제    중간에 추가/삭제    검색
        ArrayList : 순차 = 빠름 | 중간 = 느림 | 검색 = 빠름
        LinkedList : 순차 = 느림 | 중간 = 빠름 | 검색 = 느림

    Set 인터페이스
        HashSet, TreeSet, LinkedHashSet ...
        특징 : 중복저장 불가
        저장순서 유지 안함

        LinkedHashSet : 이놈은 저장순서를 유지해줌
        TreeSet : 이진검색트리 자료구조 형태로 데이터 저장(뭔말인지?)
            정렬된 위치에 저장 -> 정렬된다!
            정렬, 검색, 범위검색 등에서 높은 성능을 보임

Map 인터페이스 (얘는 Colletion 클래스를 상속하는 인터페이스는 아냐)
    MashMap, TreeMap ...
    특징 : 데이터를 짝꿍 형태로 담아줘야 함 (K,V)
    Key, Value 구조
        key - 중복 불가 / value - 중복 가능

Iterator 인터페이스
    Colletion에 저장된 요소를 접근하는데 사용
    접근방식의 표준화

Generics : 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스 컴파일 시의 타입 체크
    사용 이유 : 제네릭스를 한다면 요소값 입력 시 안정적인 데이터 입력이 가능, Object해봐 뭘 넣어도 컴파일 오류가 안가니까
    Box<T>
        Box : 원시 타입
        T(무조건 대문자) : Type variable - 타입 변수 혹은 타입 매개변수
        E : Element
    와일드 카드
        <? extends T> : T 클래스와 그 자손들의 타입만 가능
        <? super T> : T 클래스와 그 조상들의 타입만 가능
        <?> : 제한 없음

sort() : sort 대상의 클래스가 Comparator(새로운 정렬기준)이나 Comparable(기본정렬기준-오름,내림)을 구현해야함

public static <T extends Comparable<? super T>> void sort(List<T> List)
    - <T extends Comparable<T>> : T는  Comparable를 구현한 클래스여야 한다.
        ex. - Person(부모 클래스)
            - class Person implements Comparable{}
            - T : Student
            - class Student extends Person