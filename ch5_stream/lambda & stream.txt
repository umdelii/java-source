람다식 
 : 함수형 언어의 장점을 이용

자바스크립트
const func = () => {}

자바
class A{
    void func(){}
}
A obj = new A();
obj.func();
    -> 이걸 편하게 자바에서도 함수식을 쓰기 위해 만든 언어가 람다식

ex. int max(int a, int b){return a > b ? a : b;}
    => 람다식으로 변경 : (int a, int b) -> {return a > b ? a : b;}
        => (int a, int b) -> a > b ? a : b;
        => (a, b) -> a > b ? a : b;

함수형 인터페이스 

기본개념
인터페이스 작성 => 구현 클래스를 작성 > 구현 클래스의 객체 생성 후 사용
 or 익명 클래스 이용 : 여러번 사용하지않고 일회성으로 사용할 때 이용함

java.util.function 패키지
 - 함수형 인터페이스를 작성해야하는 번거러움을 제거 
 - java.lang.
 - Runnable void run(); : 매개변수 없고, 리턴타입 없음
 - Sulppier<T> T get() : 매개변수 없고, 리턴타입 있음
 - Consumer<T> void accept(T t) : 매개변수 있고, 리턴타입 없음
 - Function<T,R> R apply(T t) : 매개변수 있고, 리턴타입 있음
    T 타입으로 받아서 R 타입으로 리턴
 - Predicate<T> boolean test(T t) : 매개변수 있고, 리턴타입 있음

 매개변수가 2개인 함수형 인터페이스
 - BiConsumer<T,U> void accept(T t,U u) : 두 개의 매개변수 있고, 리턴타입 없음
 - BiFunction<T,U,R> R apply(T t,U u) : 두 개의 매개변수 있고, 리턴타입 있음
 - BiPredicate<T,U> boolean test(T t,U u) : 두 개의 매개변수 있고, 리턴타입 있음

**** 중괄호가 빠지면 return이라는 뜻 ****

-----------------------------------------------------------------------------------------

컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 for, iterator를 사용함
 -for나 iterator...의 단점 : 재사용성 떨어짐, 데이터 소스마다 다른 방식으로 다뤄야 함
=> 그래서 스트림이 등장

스트림
 - 원본 데이터 소스로부터 데이터를 읽어올 뿐 변경하지는 않음
 - 일회용
 - 작업을 내부 반복으로 처리

스트림 연산
 1. 중간연산
    연산 결과가 스트림인 연산 / 스트림에 연속해서 중간 연산할 수 있음
    distinct()
    filter()
    limit(long maxSize)
    skip(long n)
    peek(consumer<T> action)
    sorted()
    map(Function<T,R> function)

 2. 최종연산
    연산 결과가 스트림이 아닌 연산 / 스트림 요소를 소모하므로 단 한 번만 가능
    forEach(Consumer<? super T> action)
    count()
    max(Comparator<? super T> comparator)
    min(Comparator<? super T> comparator)
    collect(Collector<T,A,R> collector)

Optional<T>
OptionalInt
OptionalDouble